- Feature Name: `wyll`
- Start Date: `11-10-17`
- RFC PR: (leave this empty)
- See also: RFC#rtti

# Summary

This provides a general summary of the compilation process from Whiley
to low-level target platforms (e.g. JavaScript, Java, C, etc).  As
part of this, the Whiley Low Level Language (WyLL) is introduced as an
abstraction to simplify code generators.

# Motivation

In constructing code generators from WyIL to different target
platforms (e.g. JavaScript, Java, C, etc) a number of common problems
have arisen.  The purpose of this document is to detail those problems
and their solutions.  In addition, this document introduces the Whiley
Low Level Language (WyLL) which provides an abstraction layer that
sits below WyIL.  The purpose of this abstraction layer is to provide
generic solutions to the various problems discussed.

By far, the hardest problems in compiling for a target platform stem
from the complex nature of Types in Whiley.  Complex types mostly
(though not exclusively) arise through flow typing. Consider this Whiley code:

```
function f(int|null x) -> (int r):
    if x is int:
        return x
    else:
        return 0
```

Here, the type of `x` is `(int|null)&int)` on the true branch and
`(int|null)&!int` on the false branch.  _But, how should such types be
represented on a given target platform?_ Such types are retained at
the WyIL level because they include useful nominal information which
(amongst other things) is important for error reporting and
verification.

The above types for `x` can easily be simplified to `int` and `null`
respectively.  But that raises another question: _can all types be
simplified in some way?_ In fact, the answer is no, though there are
useful approximations we can use.

# Technical Details

This document is concerned with the compilation of Whiley programs to
a range of target platforms, including JavaScript, Java and C.  Other
platforms, such as LLVM and WebAssembly are also of interest.  Whilst
each of these platforms has differences, they also have a lot in
common.  

The Whiley Low Level Language can be though of as a simple imperative
language that strips away much of the complexity found in Whiley's
type system and semantics.  The intention is that this captures the
commonalities across all target platforms considered here.  We can
summarise these commonalities as follows:

- **Types**.  We assume the target platform provides a range of
  primitive types.  This includes _booleans_, _fixed-width_ and
  _unbound integers_, _arrays_, _records_, _references_ and _lambdas_
  (a.k.a. function pointers or closures).  Furthermore, we assume that
  reference types have a finite representation regardless of what they
  refer to.  Finally, we assume that recursive types are not natively
  supported and, instead, must simulated using references.

- **Value Semantics**.  We assume the target platform does not
  necessarily provide value semantics for all types.  For example,
  arrays and objects in Java have reference semantics.  As such,
  cloning of values is necessary at different points, though the exact
  details are platform specific.

- **Methods**.  We assume the target platform provides a general
  concept of a function or method which can be invoked.  Whilst this
  can accept zero or more parameters, we assume it only supports zero
  or one return (i.e. not platform we are aware of natively supports
  multiple returns).  In addition, whilst overloading may be possible
  on the target platform, we assume true overloading of Whiley types
  is not possible.  As such, a mechanism for _name mangling_ is
  required.

- **Statements & Expressions.** We assume the usual range of
  statements and expressions is supported.  This includes
  conditionals, loops, switches, etc.  In general, translation of
  statements and expressions in Whiley to WyLL is straightforward and
  is largely ignored in this document.

We note that each platform supports these features in different ways.
The WyLL is intended to be parameterised to enable these differences
to be accounted for.

## Type Maps

## Type Representation

## Type Tests

## Type Coercions

## Name Mangling

## Borrowing

-- Value semantics

## Multiple Returns

No target platform that we're aware of natively supports multiple
returns (though, potentially, something like LLVM might).  Therefore,
multiple returns are compiled away when generating WyLL and this is
relatively straightforward.  For assignments it's really easy, for
multiple returns it's _slightly_ harder (to do well).

**Multiple Assignments**.  Consider a multiple assignment like this:

```
int x, int y, int z 

x,y,z = 1,f()
```

Here, `f()` returns two `int`s.  The obvious translation is this:

```
x = 1
{int f1, int f2} tmp = f()
y = tmp.f1
z = tmp.f2
```

_Obviously, we need to be careful about the variable name introduced
to prevent clashes._

**Multiple Returns**.  These can be handled in exactly the same way
  above by reusing the declared returns.  However, we might want
  something neater in some cases.  For example, we could translate
  this:

```
return x,y
```

into this:

```
return {x: x, y: y}
```

But, of course, we can't do that with an actual multiple return.
Therefore, this:

```
return x,f()
```
becomes this:

```
{int f1, int f2} tmp = f()
return x, tmp.f1, tmp.f2
```

_However, care needs to be taken for side-effecting expressions as
these must still be evaluated in the correct order._

## Trampolines

# Terminology

# Drawbacks and Limitations

# Unresolved Issues

